/**
 * 
 */
package compiler.canonicalize;

import java.util.ArrayList;
import java.util.List;
import java.util.Set;

import compiler.Context;
import compiler.Symbol;
import compiler.SymbolRebuildVisitor;
import compiler.SymbolType;
import compiler.Utils;

/**
 * @author Michael
 * 
 */
public class AutoGeneratedSymbolTypeCanonicalizer {
	public static Symbol canonicalize(Symbol symbol) {
		return Visitor.canonicalize(symbol);
	}

	/**
	 * Inlines a one-of symbol with it's component
	 */
	private static class Visitor extends SymbolRebuildVisitor {
		private static final Visitor INSTANCE = new Visitor();

		public static Symbol canonicalize(Symbol symbol) {
			Symbol visited = INSTANCE.visit(symbol);
			
			// unpack top-level option type
			if (symbol.type().context().getOptionComponentType(visited.type()) != null)
			{
				Utils.check(visited.children().size() <= 1, "Bad child count for Option type");
				return visited.children().isEmpty() ? null : visited.children().get(0);
			}
			
			return visited;
		}

		@Override
		protected Symbol visitNonTerminal(Symbol symbol) {
			Context context = symbol.type().context();

			// inline one-of
			Set<SymbolType> oneOfComponentTypes = context.getOneOfComponentTypes(symbol.type());
			if (oneOfComponentTypes != null) {
				Utils.check(symbol.children().size() <= 1, "Bad child count for OneOf type");
				return this.visit(symbol.children().get(0));
			}

			// flatten list
			SymbolType listElementType = context.getListElementType(symbol.type());
			if (listElementType != null) {
				SymbolType separatorType = context.getListSeparatorType(symbol.type());
				SymbolType listHelperType = context.getListHelperType(symbol.type());
				List<Symbol> collectedChildren = new ArrayList<Symbol>();
				if (this.collectAndVisitListChildren(symbol, listElementType, separatorType, listHelperType,
						collectedChildren)) {
					return symbol.type().createSymbol(collectedChildren);
				}
			}

			// deal with types that might flatten into multiple values
			List<Symbol> rebuiltChildren = null;
			for (int i = 0; i < symbol.children().size(); ++i) {
				Symbol child = symbol.children().get(i);
				
				// inline or remove option
				SymbolType optionComponentType = context.getOptionComponentType(child.type());
				if (optionComponentType != null) {
					Utils.check(child.children().size() <= 1, "Bad child count for Option type");
					rebuiltChildren = setUpRebuiltChildren(rebuiltChildren, symbol, i);
					rebuiltChildren.addAll(child.children());
					continue;
				}
				
				// inline tuple
				List<SymbolType> tupleTypes = context.getTupleComponentTypes(child.type());
				if (tupleTypes != null) {
					Utils.check(child.children().size() == tupleTypes.size(), "Bad child count for Tuple type");
					rebuiltChildren = setUpRebuiltChildren(rebuiltChildren, symbol, i);
					rebuiltChildren.addAll(child.children());
					continue;
				}
				
				// if we are rebuilding children, keep adding each child
				if (rebuiltChildren != null) {
					rebuiltChildren.add(child);					
				}
			}
			if (rebuiltChildren != null) {
				// note that we need to re-visit the new symbol in this case to handle flatting things like
				// option(option(A)). The first pass will go to option(A), and the second pass will go to A
				return this.visit(symbol.type().createSymbol(rebuiltChildren));
			}

			return super.visitNonTerminal(symbol);
		}

		private static List<Symbol> setUpRebuiltChildren(List<Symbol> rebuiltChildren, Symbol symbol, int index) {
			if (rebuiltChildren != null) {
				return rebuiltChildren;
			}

			List<Symbol> result = new ArrayList<Symbol>(symbol.children().size());
			for (int i = 0; i < index; ++i) {
				result.add(symbol.children().get(i));
			}
			return result;
		}

		private boolean collectAndVisitListChildren(Symbol list, SymbolType listElementType, SymbolType separatorType,
				SymbolType listHelperType, List<Symbol> collectedChildren) {
			boolean changed = false;
			for (int i = 0; i < list.children().size(); ++i) {
				Symbol child = list.children().get(i);
				// if we see a list type, recurse to collect it's children
				if (child.type().equals(list.type()) || child.type().equals(listHelperType)) {
					this.collectAndVisitListChildren(child, listElementType, separatorType, listHelperType, collectedChildren);
					changed = true;
				} else if (child.type().equals(listElementType) || child.type().equals(separatorType)) {
					Symbol visitedChild = this.visit(child);
					collectedChildren.add(visitedChild);
					changed |= child != visitedChild;
				} else {
					Utils.err("Unexpected list child type " + child.type());
				}
			}

			return changed;
		}
	}
}
